<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Doomslug | NEAR Analysis</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/near-styles.css">
		<link rel="stylesheet" href="dist/theme/moon.css">

		<meta name="description" content="Team Doomslug's evaluation of the NEAR Whitepaper.">
		<meta name="author" content="Team Doomslug">

		<link rel="stylesheet" href="plugin/highlight/monokai.css">
	</head>
	<body>
		<div class="reveal">
			<div class="slides l-stack">
				<section data-transition="slide">
					<div>
						<img class="logo" src="assets/near-logo.svg" />
					</div>

					<ul class="mt">
						<li>Arthur Santos</li>
						<li>Leonardo Razovic</li>
						<li>Marijo Radman</li>
						<li>Sam Ruberti</li>
						<li>Tom Pignard</li>
					</ul>

					<div class="mt">
						<a href="https://near.org/papers/the-official-near-white-paper/">https://near.org/papers/the-official-near-white-paper</a>
					</div>
					<p>(Not financial advice)</p>
				</section>

				<section data-transition="slide">
					<h2>Outline</h2>

					<ul class="mt">
                      <li>Introduction</li>
                      <li>Economics</li>
                      <li>Cryptography</li>
                      <li>Governance</li>
                      <li>Guarantees</li>
                      <li>Structure</li>
                      <li>Threat Models</li>
                      <li>Conclusion</li>
					</ul>
				</section>

				<section data-transition="zoom" data-background-color="#d33682">
					<h2>Introduction</h2>
				</section>

				<section data-transition="slide">
					<h4>🥑 Core offerings</h4>
					<p>
						NEAR is a community run blockchain-cloud built on Rust that allows <b>developers</b> to sustainably build applications which secure high value assets while making them performant and "infinitely scalable."
					</p>
				</section>

				<section data-transition="slide">
					<h4>🤷‍ What can users do?</h4>
					<ul>
						<li>
							Developers can build services in a permissionless environment and receive <b>rewards</b> when consumers interact with their applications.
						</li>
						<li>
							Token holders can interact with applications with <b>fast</b> transaction speeds and <b>low fees</b>, and they can <b>stake</b> their assets to earn rewards through a Proof of Stake mechanism.
						</li>
					</ul>
				</section>

				<section data-transition="slide">
					<h4>❄ Uniqueness</h4>
					<ul>
						<li>
							The economic model is built around the devloper first and introduces a deflationary mechanism for the token - a large portion of the transaction fees are burned.
						</li>
						<li>
							NEAR is a sharded, proof of stake, layer-one blockchain and claims to be infinitely scalable.
						</li>
					</ul>
				</section>

				<section data-markdown data-transition="zoom" data-background-color="#2aa198">
					<textarea data-template>
						## Economics
					</textarea>
				</section>

				<section data-markdown data-transition="slide">
					<textarea data-template>
						### 💰 The NEAR token

						NEAR is the native token used for
						* <b>Security</b> of the network (PoS)
						* Medium of exchange
							- Network <b>transactions</b>
							- Network <b>storage</b>

						The initial supply was 1 billion tokens

						---

						### ☯️ Market Equilibrium
						There are three main economic forces in NEAR that affect the total supply

						* <b>Developers</b>
						* <b>Token holders</b>
						* <b>Inflation</b>
					</textarea>
				</section>

				<section data-markdown data-transition="slide">
					<textarea data-template>
						#### ️💻 Developers
						<span class="fragment fade-in-then-semi-out">Developers are rewarded for creating useful applications. They receive <b>30%</b> of a user's transaction fees when their contracts are called.</span>
						<span class="fragment fade-in">The remaining <b>70%</b> is burned🔥.
					</textarea>
				</section>

				<section data-markdown data-transition="slide">
					<textarea data-template>
						#### 👨‍💼 Token Holders
						<span class="fragment fade-in-then-semi-out">
							Active users <b>decrease</b> the total supply of the token via the burned portion of their transaction fees.
						</span>

						<span class="fragment fade-in">
							Inactive users allow the total supply to <b>increase</b> via inflation.
						</span>
					</textarea>
				</section>

				<section data-markdown data-transition="slide">
					<textarea data-template>
						#### 📈 Inflation

						* Validators receive rewards based on a <b>5%</b> annual inflation rate. <b>4.5%</b> of these rewards are distributed to active validators based on the percentage of their stake.
						* <b>0.5%</b> of the annual rewards are given to the treasury. 
					</textarea>
				</section>

				<section data-markdown data-transition="slide">
					<textarea data-template>
						#### ⚖️ In Summary
						
						Market equilibrium is dynamic based on the opposing forces of network <b>participation</b> and <b>inflation</b>. 

						<table class="mt">
							<thead>
								<tr>
									<th>tx/day</th>	
									<th>NEAR / day</th>
									<th>Ann Inflation</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>1,000</td>
									<td>136,986</td>
									<td>5.000%</td>
								</tr>
								<tr>
									<td>1 Million</td>
									<td>136,986</td>
									<td>4.996%</td>
								</tr>
								<tr>
									<td>1.5 Billion</td>
									<td>-13,014</td>
									<td>-0.475%</td>
								</tr>
								<tr>
									<td><b>2 Billion</b></td>
									<td>-64,014</td>
									<td><b>-2.300%</b></td>
								</tr>
							</tbody>
						</table>
					</textarea>
				</section>

				<section data-markdown data-transition="slide">
					<textarea data-template>
						#### 🎭 Tragedy of the Commons
						
						* In game theory Tragedy of the Commons states that <b>over consumption</b> of a common good by an individual inflicts damage on the rest. 
						
						* Over fishing, for example, provides the optimal benefit for the <b>individual</b>, but decreases the total fish population. 
					</textarea>
				</section>

				<section data-markdown data-transition="slide">
					<textarea data-template>
						#### 🗃 Blockchain Storage is Common Good

						* It is possible for the market to become flooded with applications and <b>bloat storage</b>.

						* NEAR therefore requires developers to maintain a <b>wallet balance</b> in proportion to the storage that their applications consume.
					</textarea>
				</section>

				<section data-markdown data-transition="slide">
					<textarea data-template>
						#### 🤷‍♂️️ What does this do?

						* There is an <b>opportunity cost</b> with maintaining a wallet balance because those funds cannot be staked loose their value proportional to inflation.

						* The number of applications you can release are limited to your budget.

						* <b>Useful</b> applications will pay for themselves through transaction fees (or other) gains. 

						* <b>Unuseful</b> application will cost money.

					</textarea>
				</section>

				<section data-markdown data-transition="slide">
					<textarea data-template>
						#### ‍🤜️️🤛 || 🔪 Public Good Game

						The Validators are slashed for <b>bad behavior</b> (more later) and rewarded for <b>good behavior</b>. Validators do not have any rational reason to misbehave.

					</textarea>
				</section>

				<section data-markdown data-transition="slide">
					<textarea data-template>
						#### 👍 What we like

						The lockup and vesting schedule of the team and founders is very fair. They have a long term commitment to the project, which will bring the most quality to the project over the five years. They also took a small percentage of the overall token distribution and probably deserved more! (The reason is probably that they raised money in a bear market).
					</textarea>
				</section>

				<section data-markdown data-transition="slide">
					<textarea data-template>
						#### 👍 What we like

						Developers receive rewards for useful applications. This incentive is a great way to build the ecosystem with quality services, attract developers, and counter inflation.
					</textarea>
				</section>

				<section data-transition="slide">
					<h4>👎 What we don't like</h4>
					<p>
						NEAR took a lot of investments giving investors 24% of the tokens in addition to another 12% in community sales. This amount is unsual. There is also no lockup schedule for investors and only 24-36 months vesting schedule. The investors therefore do not have a long time incentive for the project and it puts selling pressure on the entire ecosystem in the early stage. In addition, the inflation is not put on the investors, which means that the community pays for the block rewards. We feel that the investors got a free ride and their rewards were unfairly balanced.
					</p>
				</section>

				<section data-transition="slide">
					<h4>👎 What we don't like</h4>
					<p>
						The guard against the Tragedy of the Common good is only as strong as the current inflation rate. With 2 billion transactions per day the effective inflation rate would be -2.3%.  We would add a linear payment mechanism to developers based on storage size if inflation dropped below 1% to make storage a little more “painful.” The performance of the application itself would need to be exceptional to justify its existence in storage.
					</p>
				</section>

				<section data-markdown data-transition="zoom" data-background-color="#cb4b16">
					<textarea data-template>
						## Cryptography
					</textarea>
				</section>

				<section data-transition="slide">
					<h4>✍ Digital Signatures</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							NEAR supports accounts derived from a public/private key scheme based on either curve <b>SECP256K1</b> or <b>Ed25519</b> (dalek library).
						</li>
						<li class="fragment fade-in-then-semi-out">
							The support of SECP256K1 is useful to maintain some compatibility layer with <b>Bitcoin</b> & <b>Ethereum</b>.
						</li>

						<li class="fragment fade-in-then-semi-out">Most protocol operations effectively require <b>Ed25519</b> to be used.</li>
					</ul>
				</section>

				<section data-transition="slide">
					<h4>📮 Accounts</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							Public addresses are referenced my a DNS-like name by default (e.g. <b>alice.near</b>)
						</li>

						<li class="fragment fade-in-then-semi-out">
							<b>Multiple</b> key pairs can be associated with an single account.
						</li>

						<li class="fragment fade-in-then-semi-out">
							<b>FunctionCall</b> keys grant privileges to key pairs for specific functions with predefined max token allowances. (Similar to Stash / Controller accounts in Substrate, but more granular)
						</li>
					</ul>
				</section>

				<section data-transition="slide">
					<h4>#️⃣ Hash Functions</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							<b>SHA2-256</b> is used for most data structures.
						</li>

						<li class="fragment fade-in-then-semi-out">
							This hash function is battle-tested, but <b>slower</b> than Blake2/3.
						</li>

						<li class="fragment fade-in-then-semi-out">
							<b>Blake2b</b> is used in the new randomness beacon, but...
						</li>

						<li class="fragment fade-in-then-semi-out">
							It is not clear why they do not use Blake2 in <b>all</b> cases.
						</li>
					</ul>
				</section>

				<section data-transition="slide">
					<h4>🌳 Merkle-Patricia Tries</h4>

					<p>Merkle-Patricia tries are used to record the chain state</p>

					<img 
						class="mt" 
						style="width: 600px; padding:20px; background-color: white; border-radius: 24px;" 
						src="assets/merkle-trie.svg" 
					/>
				</section>

				<section data-transition="slide">
					<h4>🔬 Merkle Proofs</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							<b>Cannot</b> be tampered with without changing the root of the tree.
						</li>

						<li class="fragment fade-in-then-semi-out">
							The tree roots are included into the blocks, producing a compact commitment for the whole state data.
						</li>
					</ul>
				</section>

				<section data-transition="slide">
					<h4>🔗 Hash Lists</h4>
					<p>
						The chain itself is a hash list, where each block refers to its parent by including the parent's header hash in its own header.
					</p>

					<img 
						class="mt fragment fade-in" 
						style="width: 600px; padding:20px; background-color: white; border-radius: 24px;" 
						src="assets/hash-list.svg" 
					/>
				</section>

				<section data-transition="slide">
					<h4>📝 Erasure Coding</h4>
					
					<ul>
						<li class="fragment fade-in-then-semi-out">
							Erasure coding is in the consensus itself.
						</li>

						<li class="fragment fade-in-then-semi-out">
							Each validator of a shard sends erasure coded data to validators of other shards.
						</li>

						<li class="fragment fade-in-then-semi-out">
							Ensures that only <b>1/3</b> of the validators can reconstruct data for all shards.
						</li>

						<li class="fragment fade-in-then-semi-out">
							Data availability is enforced at consensus level by forcing validators to check whether the data is available before they accept a block.
						</li>
					</ul>
				</section>

				<section data-transition="slide">
					<h4>✍✍✍ Signature Aggregation > ✍</h4>
					
					<ul>
						<li class="fragment fade-in-then-semi-out">
							Block producers collect signatures of all validators and aggregate them with <b>BLS</b>.
						</li>

						<li class="fragment fade-in-then-semi-out">
							Aggregated signatures are published in a Merkle Trie of the individual signatures, and signed using <b>ECDSA</b>.
						</li>

						<li class="fragment fade-in-then-semi-out">
							Nodes that are syncing chain data can choose to skip the validation of individual signatures and merely <b>verify the ECDSA</b> signature from the validator (if the validator has not been challenged or slashed)
						</li>
					</ul>
				</section>

				<section data-transition="slide">
					<h4>🔎 🎲🎲 Verifiable Random Function</h4>
					
					<ul>
						<li class="fragment fade-in-then-semi-out">
							VRFs are used in the new random beacon to generate randomness that's both unpredictable and unbiasable.
						</li>

						<li class="fragment fade-in-then-semi-out">
							The randomness beacon is based on BLS signatures, and allows any given subset <b>k < n</b> of <b>n</b> nodes to produce randomness without any node set of size <b>k - 1</b> being able to learn any information about the randomness beacon.
						</li>
					</ul>
				</section>

				<section data-transition="slide">
					<h4>🧠 Succint Non-interactive ARguments of Knowledge (SNARK)</h4>
					
					<ul>
						<li class="fragment fade-in-then-semi-out">
							NEAR relies on <b>fishermen</b> to ensure the security of shards (more later).
						</li>

						<li class="fragment fade-in-then-semi-out">
							This is a fraud-proof approach that is cheap and easy to implement but the tradeoff is the negative impact on <b>liveness</b> and <b>speed</b> of the protocol due to the challenge period.
						</li>

						<li class="fragment fade-in-then-semi-out">
							NEAR plans to switch to a validity proof where each chunk producer would provide a <b>SNARK</b> attesting to the chunk validatity.	
						</li>
					</ul>
				</section>

				<section data-transition="slide">
					<h4>👍 What we like</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							The plan for bleeding edge primitives (SNARKS)
						</li>

						<li class="fragment fade-in-then-semi-out">
							Erasure coding to solve <b>data availability</b> issues - using a set of notaries keep long term data.
						</li>

						<li class="fragment fade-in-then-semi-out">
							Unbiased and unpredictable randomness for every <b>validator selection</b> using VRF (vs round-robin).
						</li>

						<li class="fragment fade-in-then-semi-out">
							The use of <b>BLS aggregation</b> of the signatures, which is elegant and efficient for a large number of validators. The final list is signed by <b>ECDSA</b>. Fast.
						</li>
					</ul>
				</section>

				<section data-transition="slide">
					<h4>👎 What we don't like</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							Most hashes are created from SHA2-256, which is <b>older</b> and <b>slower</b> than Blake2b.
						</li>

						<li class="fragment fade-in-then-semi-out">
							The current challenge/response mechanism affects the protocol <b>liveness</b>.
						</li>

						<li class="fragment fade-in-then-semi-out">
							The use of BLS aggregation is optimal for large signature lists, but there are currently only <b>100 validators</b>. 
							If the number of validators increases, the Schnorr interactive aggregation phase may become unpractical.
						</li>
					</ul>
				</section>

				<section data-markdown data-transition="zoom" data-background-color="#6c71c4">
					<textarea data-template>
						## Governance
					</textarea>
				</section>

				<section data-transition="slide">
					<h4>🏛 Off-Chain Governance</h4>
					<p>NEAR is currently maintained by a <b>centralized</b> entity that makes decisions off-chain. There are plans to create a governance body on-chain in the future, but they argue that a democracy would inhibit initial development velocity.</p>
				</section>

				<section data-transition="slide">
					<h4>💂 Reference Maintainer</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							All discussions regarding proposals take place in the <b>NEAR Governance Community</b>.
						</li>

						<li class="fragment fade-in-then-semi-out">
							A Reference Maintainer is selected to oversee <b>technical</b> responsibilities.
						</li>
					</ul>
				</section>

				<section data-transition="slide">
					<h4>👍 What we like</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							 At least the NEAR Governance forum is <b>public</b> and <b>no registration</b> is required. (Unlike Discord, etc).
						</li>

						<li class="fragment fade-in-then-semi-out">
							They recognize that the current situation is <b>not ideal</b>.
						</li>

						<li class="fragment fade-in-then-semi-out">
							Without a democracy <b>decision making speed</b> is fast.
						</li>

						<li class="fragment fade-in-then-semi-out">
							The code is open source. Terrible decisions can be corrected with a <b>hard fork</b>.
						</li>
					</ul>
				</section>

				<section data-transition="slide">
					<h4>👎 What we don't like</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							The Reference Maintainer is elected by NEAR Foundation and is no different than a <b>Web 2.0</b> company.
						</li>
						
						<li class="fragment fade-in-then-semi-out">
							The Foundation makes all final decisions, but has <b>obligations</b> to their investors and have their own self-interests.
						</li>

						<li class="fragment fade-in-then-semi-out">
							Voting is <b>opaque</b> and not verifiable.
						</li>
					</ul>
				</section>

				<section data-markdown data-transition="zoom" data-background-color="#cb4b16">
					<textarea data-template>
						## Structure
					</textarea>
				</section>

				<section data-transition="slide">
					<h4>🧩 Shards</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							Consensus across all nodes for all shards is achieved through NEAR's <b>Nightshade</b> algorithm.
						</li>

						<li class="fragment fade-in-then-semi-out">
							Nightshade assumes that all of the shards combine to produce a <b>single block</b>, and each block “contains” all the transactions for all the shards.
						</li>

						<li class="fragment fade-in-then-semi-out">
							There are no shard chains in Nightshade. All block producers and validators are working together to create a single blockchain, which we refer to as the <b>Main Chain</b>.
						</li>
					</ul>
				</section>

				<section data-transition="slide">
					<h4>🧩 🧩 > 🤝 Consensus</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							Consensus is achieved via the <b>heaviest chain</b>.
						</li>

						<li class="fragment fade-in-then-semi-out">
							Block producers (BPs) <b>collect signatures</b> from other BPs and validators attesting to the previous block.
						</li>

						<li class="fragment fade-in-then-semi-out">
							The cumulative stake of all signers determines the <b>weight</b> of a block.
						</li>

						<li class="fragment fade-in-then-semi-out">
							For each block (and <b>every shard</b>) there is one BP who is responsible to produce a <b>chunk</b>.
						</li>

						<li class="fragment fade-in-then-semi-out">
							A chunk contains the list of the <b>transactions</b> and the <b>Merkle root</b> of the resulting state.
						</li>
					</ul>
				</section>

				<section data-transition="slide">
					<h4>🏁 Finally</h4>

					<p>
						Finally a header is created for all chunks containing the merkle root of the <b>final state</b>.
					</p>

					<img src="assets/beacon-nightshade.png" />
				</section>

				<section data-transition="slide">
					<h4>🧩 One more thing on Shards...</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							Blocks are produced more-or-less every <b>second</b> regardless if individual shards have produced its chunk for that specific block height.
						</li>

						<li class="fragment fade-in-then-semi-out">
							If a transaction needs to affect more than one shard, it needs to be consecutively executed in each shard <b>separately</b>.
						</li>
					</ul>
				</section>

				<section data-transition="slide">
					<h4><img style="vertical-align:middle" src="assets/doomslug.png" alt="Doomslug" width="45" height="45"> Doomslug</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							Doomslug is a protocol to assure honesty of validators but <b>slashing</b> bad actors.
						</li>

						<li class="fragment fade-in-then-semi-out">
							Doomslug establishes <b>finality</b> and is <b>irreversible</b> unless at least one participant is slashed.	
						</li>
					</ul>
				</section>

				<section data-transition="slide">
					<h4>🏗 Architecture</h4>
					<p>
						<b>Contract</b> calls are executed inside the WASM runtime (security). Other calls are executed in the <b>native client</b>.
					</p>

					<img style="width: 500px" src="assets/near-diagram.png" />
				</section>

				<section data-transition="slide">
					<h4>🧱 Block</h4>
					<p>The block is mainly composed of a <b>BlockHeader</b> and a vector of chunks from the <b>different shards</b>.</p>
					<pre>
						<code>
							#[derive(BorshSerialize, BorshDeserialize, Debug, Clone, Eq, PartialEq)]
							pub struct BlockV2 {
								pub header: BlockHeader,
								pub chunks: Vec{ShardChunkHeader},
								pub challenges: Challenges,
							
								pub vrf_value: near_crypto::vrf::Value,
								pub vrf_proof: near_crypto::vrf::Proof,
							}
						</code>
					</pre>
				</section>

				<section data-transition="slide">
					<h4>💆‍♂️ Header</h4>
					<p>
						The header contains the <b>hash</b> of the previous block, the <b>signature</b> of the block producer, the <b>hash</b> of the current block, and some <b>metadata</b> structs.
					</p>
					<pre>
						<code>
							pub struct BlockHeaderV3 {
								pub prev_hash: CryptoHash,
								/// Inner part of the block header that gets hashed, split into two parts, one that is sent
								/// to light clients, and the rest
								pub inner_lite: BlockHeaderInnerLite,
								pub inner_rest: BlockHeaderInnerRestV3,
								/// Signature of the block producer.
								pub signature: Signature,
								/// Cached value of hash for this block.
								pub hash: CryptoHash,
							}
						</code>
					</pre>
				</section>

				<section data-transition="slide">
					<h4>🧾 Receipts</h4>
					<p>
						All cross-contract communication in NEAR happens through <b>Receipts</b>. The STF does the following:
					</p>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							Snapshot the initial state.
						</li>

						<li class="fragment fade-in-then-semi-out">
							Apply validator accounts update, if available.
						</li>

						<li class="fragment fade-in-then-semi-out">
							Convert new signed transactions into the Receipts.
						</li>

						<li class="fragment fade-in-then-semi-out">
							Process Receipts.
						</li>

						<li class="fragment fade-in-then-semi-out">
							Check that incoming and outgoing balances match.
						</li>

						<li class="fragment fade-in-then-semi-out">
							Finalize trie update.
						</li>

						<li class="fragment fade-in-then-semi-out">
							Return ApplyResult
						</li>
					</ul>
				</section>

				<section data-transition="slide">
					<h4>👍 What we like</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							WebAssembly for the runtime allows for excellent <b>performance</b>. 
						</li>

						<li class="fragment fade-in-then-semi-out">
							Developers can code in any language that compiles to <b>WASM</b>, including AssemblyScript (A TypeScript-like language)
						</li>

						<li class="fragment fade-in-then-semi-out">
							Block creation and Doomslug are divided in a <b>hybrid consensus</b>. Combining these two processes enables NEAR to build blocks quickly while allowing the slower finality mechanism to operate in a <b>separate process</b> to finalise blocks without the risk of slower transactions.	
						</li>
					</ul>
				</section>

				<section data-transition="slide">
					<h4>👎 What we don't like</h4>
					<p>
						It is possible for Nightshade to have too many receipts that target a shards in a specific block. The time it takes from the creation of the receipt to the application can be longer and longer if the system is under an uneven load for an extended period of time.
					</p>
				</section>

				<section data-transition="slide">
					<h4>👎 What we don't like</h4>
					<p>
						A chunk can be invalid and therefore a challenge period was implemented. In particular, the destination shard of any cross-shard transction cannot be certain the originating shard chunk or block is final until the challenge period is over. The existence of the challenge protocol (Fisherman) creates a new vector of attacks when malicious nodes spam with invalid challenges.							
					</p>
				</section>

				<section data-markdown data-transition="zoom" data-background-color="#b58900">
					<textarea data-template>
						## Guarantees
					</textarea>
				</section>

				<section data-transition="slide">
					<h4>👼 Liveness</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							Liveness is maintained if more than 1/2 of validators are online.
						</li>

						<li class="fragment fade-in-then-semi-out">
							The block producer who's most ahead in time is the witness.
						</li>

						<li class="fragment fade-in-then-semi-out">
							If all block producers of a specific block in a specific shard are online for more time than the time necessary for the block creation, we can assume that block will be created in a finite time.	
						</li>
					</ul>
				</section>

				<section data-transition="slide">
					<h4>⚖️ Fairness</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							Validation is designed to run on hardware that is accessible by all.
						</li>

						<li class="fragment fade-in-then-semi-out">
							NEAR is a permissionless blockchain, so anyone can deploy an application.
						</li>

						<li class="fragment fade-in-then-semi-out">
							VRF is used to ensure that validator selections are unbiased.
						</li>
					</ul>
				</section>

				<section data-transition="slide">
					<h4>🦺 Safety</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							Nightshade's Finality Gadget requires more rounds of communication, but fewer blocks built on top of it till it's considered safe.
						</li>

						<li class="fragment fade-in-then-semi-out">
							Unless there's at least one block producer who's considered dishonest a produced block cannot be reversed.	
						</li>

						<li class="fragment fade-in-then-semi-out">
							A finalized block just can be reversed if more than 30% of the producers are considered dishonest.	
						</li>
					</ul>
				</section>

				<section data-transition="slide">
					<h4>🧲 Censorship Resistence</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							NEAR is opperated by the NEAR Foundation and is exposed to censorship and government interference.
						</li>

						<li class="fragment fade-in-then-semi-out">
							Token holders have little resistence to censorship from the NEAR Foundation, who decides everything.
						</li>

						<li class="fragment fade-in-then-semi-out">
							Many guilds exist on NEAR. They are communities with shared interests and a lot of token power. They can form validators to join in on consensus.
						</li>
					</ul>
				</section>

				<section data-transition="slide">
					<h4>👍 What we like</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							Doomslug provides liveness guarantess even in case where finality stalls due to more than 33% of the validators missing.
						</li>

						<li class="fragment fade-in-then-semi-out">
							The requirements to run a validator are reasonable, which helps to preserve censorship resistence by allowing censored parties to join the consensus if needed.
						</li>
					</ul>
				</section>

				<section data-transition="slide">
					<h4>👎 What we don't like</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							The number of validators is very small (100) and makes the network partially <b>centralized</b> and weakens censorship resistence.
						</li>

						<li class="fragment fade-in-then-semi-out">
							The NEAR foundation is still <b>too powerful</b>. This may result in <b>censorship</b>.
						</li>
					</ul>
				</section>

				<section data-markdown data-transition="zoom" data-background-color="#dc322f">
					<textarea data-template>
						## Threat Models
					</textarea>
				</section>

				<section data-transition="slide">
					<h4>🎖️ Byzantine generals problem</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							<b>In a distributed environment, with potentially faulty actors, reaching a consensus without the help of a central authority.</b>
						</li>
						<li class="fragment fade-in-then-semi-out">
							<b>Nightshade</b> addresses the Byzantine generals problem
						</li>
						<li class="fragment fade-in-then-semi-out">
							Nightshade provides similar guarantees as PBFT, but suffers the same drawbacks
						</li>
					</ul>
				</section>
				<section data-transition="slide">
					<h4>🎭 Sybil Attack</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							<b>In a pseudonymous environment, nothing prevents an adversary to create multiple accounts.</b>
						</li>
						<li class="fragment fade-in-then-semi-out">
							Block production and finality guarantees are based on a given proportion of consensus participants being honest.
						</li>
						<li class="fragment fade-in-then-semi-out">
							It is crucial to prevent a malicious actor to secure many validator slots.
						</li>
					</ul>
				</section>
				<section data-transition="slide">
					<h4>🎭Sybil Attack</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							Near relies on the fact that a sufficient amount of tokens need to be bounded for a validator to get a slot.
						</li>
						<li class="fragment fade-in-then-semi-out">
							As long as the token maintains sufficient value, it is expensive to create accounts that are funded enough to participate to the protocol.
						</li>
					</ul>
				</section>
				<section data-transition="slide">
					<h4>💥 51% Attack</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							In a proof-of-stake algorithm, the security of the network depends on the amount of tokens that get staked (bonded) by the participants.
						</li>
						<li class="fragment fade-in-then-semi-out">
							The security of the system can then be assessed in terms of a financial quantity (e.g. USD) depending on the price of the token.
						</li>
					</ul>
				</section>
				<section data-transition="slide">
					<h4>🔫 Finality</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							In Near, any attack that takes over the finality mechanism is fatal.
						</li>
						<li class="fragment fade-in-then-semi-out">
							Nightshade requires 2/3+1 of the validators to be honest to finalize a block.
						</li>
						<li class="fragment fade-in-then-semi-out">
							The theoretical security threshold is half in case of a network partition of the honest validators (c.f. PBFT).
						</li>
						<li class="fragment fade-in-then-semi-out">
							The theoretical security is then equal to the cost of taking other the 1/3 + 1 least bonded validators.
						</li>
					</ul>
				</section>
				<section data-transition="slide">
					<h4>🧱 Block production</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							Before finalization the security level is equal to the stash value of the block producer.
						</li>
						<li class="fragment fade-in-then-semi-out">
							After finalization, it is equal to 1/3 of the stake.
						</li>
						<li class="fragment fade-in-then-semi-out">
							Liveness badly impacted by the lack of explicit punishment for offline behaviour.						
						</li>
					</ul>
				</section>
				<section data-transition="slide">
					<h4>✨ Shard security</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							Within one shard, if the majority of the validators gets corrupted, the shard itself can be fully taken over.
						</li>
						<li class="fragment fade-in-then-semi-out">
							Validators on other shard are only operating a light-client equivalent verification on the corrupted shard.
						</li>
						<li class="fragment fade-in-then-semi-out">
							Inter-shard transactions from a corrupted shard are dangerous and propagate state corruption.
						</li>
					</ul>
				</section>
				<section data-transition="slide">
					<h4>✨ Shard security</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							Fishermen are incentivized to publish onchain challenges attesting from the invalidity of a given block shard.
						</li>
						<li class="fragment fade-in-then-semi-out">
							In case of a successful challenge, the state is reverted to the one just before the shard corruption.
						</li>
					</ul>
				</section>
				<section data-transition="slide">
					<h4>🫠 Adaptive Corruption</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							A malicious party can bribe or corrupt only a specific subset of the actors in order to take over the network, or grief other participants.
						</li>
						<li class="fragment fade-in-then-semi-out">
							A randomness beacon assigns validators to shards makes adapting corruption more difficult.
						</li>
						<li class="fragment fade-in-then-semi-out">
							"Hidden validators" whose assignment to any given shard is not meant to be released publicly further prevent adaptive behavior.
						</li>
					</ul>
				</section>
				<section data-transition="slide">
					<h4>🫠 Adaptive Corruption</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							At the main chain level, block producers are operating in following a simple round robin
						</li>
						<li class="fragment fade-in-then-semi-out">
							Validators are rotated once every epoch (15 hours), so any block that would be challenged within that period would let the set of validators exposed for the rest of the epoch.
						</li>
					</ul>
				</section>
				<section data-transition="slide">
					<h4>🚧 More practical considerations</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							Near currently operates only on one shard and with 100 validators.
						</li>
						<li class="fragment fade-in-then-semi-out">
							No incentive to homogeneize stakes
						</li>
						<li class="fragment fade-in-then-semi-out">
							The most bonded validator getting bonded for 25,000,000 NEAR tokens and the least bonded being worth only 180,000 NEAR tokens
						</li>
					</ul>
				</section>
				<section data-transition="slide">
					<h4>👍 What we like</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							Near has tentatively addressed the security challenges of proof-of-stake within a sharded blockchain.
						</li>
						<li class="fragment fade-in-then-semi-out">
							Consensus separation in block production and finality that favours liveness while  maintaining PBFT security.
						</li>
						<li class="fragment fade-in-then-semi-out">
							The problem of shard corruption spreading out being addressed through a clever use of randomness and hidden validators, with Fishermen being the end guardians.	
						</li>
					</ul>
				</section>

				<section data-transition="slide">
					<h4>👎 What we don't like</h4>
					<ul>
						<li class="fragment fade-in-then-semi-out">
							Stakes of the validators are not homogenized.
						</li>
						<li class="fragment fade-in-then-semi-out">
							The use of round robin for the main block production.
						</li>
						<li class="fragment fade-in-then-semi-out">
							In case a bad block is challenged, the validators are uncovered till the end of the epoch.
						</li>
						<li class="fragment fade-in-then-semi-out">
							No offline penalties apart from the missing reward.	
						</li>
					</ul>
				</section>
				<section data-markdown data-transition="zoom" data-background-color="#586e75">
					<textarea data-template>
						## Conclusion
					</textarea>
				</section>

				<section data-markdown data-transition="slide">
					<textarea data-template>
						### 🍺 Favorite features

						An allocation of <b>30%</b> of transaction costs to developers is a unique way how to attract talent to work on the protocol. This design feature could accelerate the adoption of NEAR Protocol and differentiate NEAR from the competition in the future.
						---
						### 🍺 Favorite features

						A UX centric approach that focuses not only on introducing new users to the network, but to make Web3 more democratic. Things such as human readable wallet addresses are one of the very prominent details that can be found on NEAR. The possibility of using Rust | AssemblyScript | Solidity to start creating on NEAR is a powerful tool for attracting non-crypto natives to the NEAR environment.
						---
						### 🥦 Least Favorite features
						
						We believe that a Layer 1 protocol, on which assets in billions, are transferred on a daily basis should not have a centralized entity like “the reference maintainer” who is able to decide by himself about the direction of a protocol.
						---
						### 🥦 Least Favorite features
						
						Cross-shard transactions are executed optimistically until challenged by fishermen if originating from an invalid block. If this happens, the chain gets rolled back to a previously valid state, potentially invalidating a full set of transactions happening within the challenge period. According to the nightshade paper, NEAR regards this as an “extremely rare event”, which is a very dangerous assumption.
					</textarea>
				</section>

				<section data-transition="slide">
					<h4>🙏 Thank You</h4>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
